package google_cloud

import (
	"context"
	"fmt"
	"prel/config"
	"sync"
	"time"

	"google.golang.org/api/cloudresourcemanager/v1"
	"google.golang.org/api/iam/v1"

	"github.com/cockroachdb/errors"
)

type Client struct {
	projectID       string
	ctx             context.Context
	resourceService ResourceManagerService
	iamService      IamService
	cacheMap        *sync.Map
}

const (
	roleGetCacheExpired = 1 * time.Hour
	// https://cloud.google.com/iam/docs/policies
	policyVersion int64 = 3
)

func NewClient(ctx context.Context, projectID string, r ResourceManagerService, i IamService) *Client {
	return &Client{
		projectID:       projectID,
		ctx:             ctx,
		resourceService: r,
		iamService:      i,
		cacheMap:        &sync.Map{},
	}
}

func (c *Client) GetProjects() ([]*cloudresourcemanager.Project, error) {
	request := c.resourceService.List()
	var projects []*cloudresourcemanager.Project
	for {

		response, err := request.Do()
		if err != nil {
			return projects, errors.Wrap(err, "failed to get projects")
		}

		projects = append(projects, response.Projects...)

		if response.NextPageToken == "" {
			break
		}

		// set next page token
		request.PageToken(response.NextPageToken)
	}

	return projects, nil
}

type roleCache struct {
	roles     []*iam.Role
	expiredAt time.Time
}

// cacheKey is used for cache key.
// cache key is projectID + principal type.
// because available iam roles are different by principal type and project(custom role).
func (c *Client) cacheKey(projectID string, t PrincipalType) string {
	return fmt.Sprintf("%s_%s", projectID, t)
}

// GetIamRoles get iam roles from cache or google cloud.
// if cache is expired, get from google cloud and set cache.
func (c *Client) GetIamRoles(now time.Time, projectID string, member BindingMember) ([]*iam.Role, error) {
	cacheKey := c.cacheKey(projectID, PrincipalType(member.PrincipalType()))
	v, ok := c.cacheMap.Load(cacheKey)
	if ok {
		cache := v.(*roleCache)
		if cache.expiredAt.After(now) {
			return cache.roles, nil
		}

		c.cacheMap.Delete(cacheKey)
	}

	req := &iam.QueryGrantableRolesRequest{
		FullResourceName: fmt.Sprintf("//cloudresourcemanager.googleapis.com/projects/%s", projectID),
		PageSize:         1000, // max page size is 1000 (default is 300)
	}
	query := c.iamService.QueryGrantableRoles(req)
	var roles []*iam.Role
	for {

		response, err := query.Do()
		if err != nil {
			return roles, errors.Wrap(err, "failed to get iam roles")
		}

		roles = append(roles, response.Roles...)

		if response.NextPageToken == "" {
			break
		}

		// set next page token
		req.PageToken = response.NextPageToken
	}

	// basic roles can't be used for conditional role bindings.
	// https://cloud.google.com/iam/docs/managing-conditional-role-bindings
	filteredRoles := ExcludeBasicRole(roles)
	filteredRoles = ExcludeRoleByPrincipalType(filteredRoles, PrincipalType(member.PrincipalType()))

	cache := &roleCache{
		roles:     filteredRoles,
		expiredAt: now.Add(roleGetCacheExpired),
	}
	c.cacheMap.Store(cacheKey, cache)

	return filteredRoles, nil
}

type BindingMember interface {
	Principal() string
	PrincipalType() string
}

func (c *Client) SetIamPolicy(ctx context.Context, projectID string, roles []string, member BindingMember, until time.Time) error {

	for _, role := range roles {
		// if set some roles, google cloud not allow to concurrent policy changes.
		// so, we need to get current policy and set new policy together in loop.
		policy, err := c.GetIamPolicy(ctx, projectID)
		if err != nil {
			return err
		}

		var binding *cloudresourcemanager.Binding
		for _, b := range policy.Bindings {
			if b.Role == role {
				binding = b
				break
			}
		}

		member := member.Principal()
		if binding != nil {
			binding.Members = append(binding.Members, member)
		} else {
			binding = &cloudresourcemanager.Binding{
				Role:    role,
				Members: []string{member},
			}
			policy.Bindings = append(policy.Bindings, binding)
		}

		binding.Condition = &cloudresourcemanager.Expr{
			// https://cloud.google.com/iam/docs/conditions-overview?hl=en#example-date-time
			// need to use  use RFC 3339 format
			Expression: fmt.Sprintf("request.time < timestamp(\"%s\")", until.Format(time.RFC3339)),

			// use for good looking in google cloud console
			Title:       fmt.Sprintf("%s_expires_after_%s", prefix(), until.Format("2006_01_02_15_04_MST")),
			Description: fmt.Sprintf("Expiring at %s generated by %s", until.Format("2006/01/02 15:04:05 MST"), config.AppName),
		}

		err = c.setIamPolicy(ctx, projectID, policy)
		if err != nil {
			return err
		}
	}

	return nil
}

func (c *Client) GetIamPolicy(ctx context.Context, projectID string) (*cloudresourcemanager.Policy, error) {
	request := &cloudresourcemanager.GetIamPolicyRequest{
		Options: &cloudresourcemanager.GetPolicyOptions{
			RequestedPolicyVersion: policyVersion,
		},
	}
	p, err := c.resourceService.GetIamPolicy(projectID, request).Do()
	if err != nil {
		return nil, errors.Wrap(err, "failed to get iam policy")
	}

	return p, nil
}

func (c *Client) setIamPolicy(ctx context.Context, projectID string, policy *cloudresourcemanager.Policy) error {

	// must bet set policy version
	// https://cloud.google.com/iam/docs/policies#versions
	if policy.Version < policyVersion {
		policy.Version = policyVersion
	}

	request := &cloudresourcemanager.SetIamPolicyRequest{
		Policy: policy,
	}

	_, err := c.resourceService.SetIamPolicy(projectID, request).Do()
	return errors.Wrap(err, "failed to set iam policy")
}

func prefix() string {
	return fmt.Sprintf("generated_by_%s", config.AppName)
}
